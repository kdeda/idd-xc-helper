//
//  Project+Sparkle.swift
//  xchelper
//
//  Created by Klajd Deda on 11/13/20.
//  Copyright (C) 1997-2024 id-design, inc. All rights reserved.
//

import Foundation
import Log4swift
import IDDSwift
import IDDSoftwareUpdate

// MARK: - Project (Sparkle) -
extension Project {
    var sparkleEnclosure: String {
        let output = Process.stdString(taskURL: Dependency.SPARKLE_SIGN, arguments: [pathToTGZ.path])
        Log4swift[Self.self].info("\(output)")
        
        // output will contain a string in the form
        // sparkle:edSignature="wWhIamodvcYgxhTGqyLJ56WCr4Hl9VXSJWlkOzBlW8tNCtpkIOoTJlwui08EE/9F2oEltal6pNZZP8NXbHtPDA==" length="10101732"
        let packageNameAndVersion = "\(packageName)_\(versionInfo.bundleShortVersionString).tgz".lowercased()
        let url = sparkle.serverURL.appendingPathComponent(packageNameAndVersion)
        
        if output.hasPrefix("sparkle:edSignature") {
            let edSignature = output.trimmingCharacters(in: CharacterSet.newlines)
            
            return "url=\"\(url.absoluteString)\" sparkle:version=\"\(versionInfo.bundleVersion)\" sparkle:shortVersionString=\"\(versionInfo.bundleShortVersionString)\" \(edSignature) type=\"application/octet-stream\"";
        }
        return "url=\"\(url.absoluteString)\" sparkle:version=\"\(versionInfo.bundleVersion)\" sparkle:shortVersionString=\"\(versionInfo.bundleShortVersionString)\" type=\"application/octet-stream\"";
    }
    
    /**
     Derive the notes.xml metadata
     */
    var notes_xml: String {
        var rv = ""
        
        rv += "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
        rv += "<!--\n"
        rv += "    autogenerated \(Date.init().description)\n"
        rv += "-->\n"
        rv += "<rss version=\"2.0\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\">\n"
        rv += "    <channel>\n"
        rv += "        <title>\(packageName) Change Log</title>\n"
        rv += "        <link>\(sparkle.serverURL)/release/notes.xml</link>\n"
        rv += "        <description>Most recent changes with links to updates.</description>\n"
        rv += "        <language>en</language>\n"
        rv += "        <item>\n"
        rv += "            <title>Version \(versionInfo.bundleShortVersionString)</title>\n"
        rv += "            <sparkle:releaseNotesLink>\(sparkle.serverURL)/release/notes.html</sparkle:releaseNotesLink>\n"
        rv += "            <pubDate>\(sparkle.releaseDate) 12:01:01 -0600</pubDate>\n"
        rv += "            <enclosure \(sparkleEnclosure) />\n"
        rv += "        </item>\n"
        rv += "    </channel>\n"
        rv += "</rss>\n"
        return rv
    }
    
    /**
     Derive the sparklecast.xml metadata
     */
    var sparklecast_xml: String {
        var rv = ""
        
        rv += "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
        rv += "<!--\n"
        rv += "    autogenerated \(Date.init().description)\n"
        rv += "-->\n"
        rv += "<!-- use a more friendly rss feed, the sparkle thing breaks the FireFox reader -->\n"
        rv += "<rss version=\"2.0\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\">\n"
        rv += "    <channel>\n"
        rv += "        <title>\(packageName) Change Log</title>\n"
        rv += "        <link>\(sparkle.serverURL)/release/notes.xml</link>\n"
        rv += "        <description>Most recent changes with links to updates.</description>\n"
        rv += "        <language>en</language>\n"
        rv += "        <item>\n"
        rv += "            <title>\(sparkle.companyName) ships \(packageName) \(versionInfo.bundleShortVersionString)</title>\n"
        rv += "            <link>\(sparkle.serverURL)/release/notes.html</link>\n"
        rv += "            <description><![CDATA[\(sparkle.companyName), a long time developer of Mac OS X software, today announced the release and immediate availability of \(packageName) \(versionInfo.bundleShortVersionString)]]></description>\n"
        rv += "            <sparkle:releaseNotesLink>\(sparkle.serverURL)/release/notes.html</sparkle:releaseNotesLink>\n"
        rv += "            <pubDate>\(sparkle.releaseDate) 12:01:01 -0600</pubDate>\n"
        rv += "            <enclosure \(sparkleEnclosure) />\n"
        rv += "        </item>\n"
        rv += "    </channel>\n"
        rv += "</rss>\n"
        return rv
    }

    /**
     The goal is to create the release/update.json file with data such that we can use it to detect
     software updates on the client.

     Since in theory someone can man in the middle to use their files we attempt to keep a valid signature
     and a valid sha256 of the file we will eventually download using downloadURL.

     At a latter day from the client side we will download the ../release/update.json from our website, which of course some can tamper with.

     But if they change the contents of downloadURL or ../release/update.json, the signature validation on the client will fail.
     */
    var update_json: String {
        let packageNameAndVersion = packageFolder.lowercased() + ".pkg"
        let downloadURL = sparkle.serverURL.appendingPathComponent(packageNameAndVersion)
        var update = UpdateInfo.init(
            buildNumber: Int(versionInfo.bundleVersion) ?? 1010,
            datePublished: Date(),
            downloadByteCount: Int(self.pathToPKG.logicalSize),
            downloadSHA256: self.pathToPKG.sha256,
            downloadURL: downloadURL,
            releaseNotesURL: sparkle.serverURL.appendingPathComponent("release/notes.html"),
            shortVersion: versionInfo.bundleShortVersionString,
            signature: updateCipherPassword // placeholder, hard to guess for someone willing to temper these
        )

        let jsonData = (try? UpdateInfo.jsonEncoder.encode(update)) ?? Data()
        let json = String(data: jsonData, encoding: .utf8) ?? ""

        update.signature = self.updatesCipher.encrypt(json)
        let decrypted = self.updatesCipher.decrypt(update.signature)

        if decrypted != json {
            // should not get here
            Log4swift[Self.self].error("failed to assert the signature. This should not happen.")
        }

        let jsonDataFinal = (try? UpdateInfo.jsonEncoder.encode(update)) ?? Data()
        let jsonFinal = String(data: jsonDataFinal, encoding: .utf8) ?? ""
        return jsonFinal
    }
}
